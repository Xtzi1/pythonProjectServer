# Напишите декоратор, который будет сохранять результаты выполнения
# декорируемой функции в словаре. Словарь должен находиться в nonlocal
# области в следующем формате: по ключу располагается аргумент функции,
# по значению результат работы функции, например, {n: f(n)}.
#
# И при повторном вызове функции будет брать значение из словаря,
# а не вычислять заново. То есть словарь можно считать промежуточной
# памятью на время работы программы, где будут храниться ранее вычисленные
# значения. Исходная функция, которую нужно задекорировать имеет следующий
# вид и выполняет простое умножение на число 123456789:
#
# def f(n):
#    return n * 123456789
#
# C помощью метода строки str.lower переведите все элементы списка в нижний регистр.

# L = ['THIS', 'IS', 'LOWER', 'STRING']
# print(list(map(str.lower, L)))

# H = [-2, -1, 0, 1, -3, 2, -3]
# def chet(x):
#    return x % 2 == 0
# result = filter(chet, H)
# print(list(result))

# d = {2 : "c", 1 : "d", 4 : "a", 3 : "b"}
# print(dict(sorted(d.items())))
# print(sorted(d.items(), key=lambda x: x[1]))

# Предположим у нас есть список с данными о росте и весе людей.
# Задача — отсортировать их по индексу массы тела. Он вычисляется по формуле:
# рост в метрах возвести в квадрат, потом массу тела в килограммах разделить на полученную цифру.
# (вес, рост)
# data = [
#    (82, 191),
#    (68, 174),
#    (90, 189),
#    (73, 179),
#    (76, 184)
# ]
#
# print(list(sorted(data, key=lambda x: x[0]/(x[1]/100)**2)))
# print(min(data, key=lambda x: x[0] / x[1] ** 2))

#
# Замените знаки «?» корректным выражением. Выведите длину каждого элемента в списке.
# a = ["asd", "bbd", "ddfa", "mcsa", 'awdsds', '11', '234dfs']
# print(list(map(lambda x: len(x), a)))
#
# Замените знаки «?» корректным выражением. Переведите все строки из списка в верхний регистр (заглавные буквы).
# a = ["это", "маленький", "текст", "обидно"]
# print(list(map(str.upper, a)))

